# IO-同步，异步，阻塞，非阻塞

## I/O模型

图1给出了同步和异步模型，以及阻塞和非阻塞的模型。

图 1.基本Linux I/O模型的简单矩阵

![](img/img-01.png)

每个I/O模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。

# 同步阻塞I/O

最常用的一个模型是同步阻塞I/O模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费CPU而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。

图2给出了传统的阻塞I/O模型，这也是目前应用程序中最为常用的一种模型。其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用read系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时，数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（read调用返回）。

图 2.同步阻塞I/O模型的典型流程

![](img/img-02.png)

举一个浅显的例子，就好比你去一个银行柜台存钱。首先，你会将存钱的单子填好，然后交给柜员。这里，你就好比是application，单子就是调用的system call，柜员就是kernel。提交好单子后，你就坐在柜台前等，相当于开始进行等待。柜员办好以后会给你一个回执，表示办好了，这就是 response。然后你就可以拿着回执干其它的事了。注意，这个时候，如果你办完之后马上去查账，存的钱已经打到你的账户上了。后面你会发现，这点很重要。




## 参考资料

* [使用异步 I/O 大大提高应用程序的性能](https://www.ibm.com/developerworks/cn/linux/l-async/)